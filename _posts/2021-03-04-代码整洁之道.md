---

layout: post
title: "代码整洁之道"
date: 2021-03-04

---

# 有意义的命名
- 使用**读得出来**的名称
- 使用**可搜索**的名称

专业的程序员了解，明确才是王道。


方法名应当是动词或动词短语，如 `postPayment`, `deletePage`, `save`。

每个概念对应一个词

反例： 同时使用 `controller`, `manager`, `driver`。

记住，只有程序员才会读你的代码。

# 函数

## 短小
函数的第一规则是要短小。第二规则是还要更短小。

`if`, `else`, `while` 等，其中的代码块应该只有一行。 *(很极端...)*

## 分层

每个函数一个抽象层级

长而具有描述性的名称，比描述性的长注释要好。

命名约定

命名方式要保持一致

`includeSetupAndTeardownPages`、`includeSetupPage`、`includeSuiteSetupPage`...

## 函数参数

最理想的参数数量是零，其次是一，再次是二，应尽量避免三。

从测试的角度看，参数多难于测试。*(条件覆盖率)*

### 标识参数

标识参数丑陋不堪。

向函数传入布尔值兼职就是骇人听闻的做法。

这样做，方法签名立刻变得复杂，大声宣布函数不止做一件事。

### 二元函数

两个参数通常没有自然顺序 `assetEqual(expected, actual)` 中， `expected` 在前， `actual` 在后， 只是一种需要学习的约定罢了。

### 参数对象

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

## 无副作用

时序性耦合

```java
appendFooter(s);
```
这个函数式把 `s` 添加到什么东西后面吗？或是把什么东西添加到了 `s` 的后面？

面向对象:

```java
report.appendFooter();
```

## 分隔指令与询问

函数要么做什么事，要么回答什么事，单二者不可得兼。

## 使用异常代替返回错误码

函数应该只做一件事情。错误处理就是一件事情。

## Don't Repeat Youself.

# 注释

> 别给糟糕的代码加注释——重新写吧！

注释并不纯然的好，实际上，注释最多也就是一种必须的恶。

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

注释存在的时间越久，就离其所描述的代码越远，原因很简单，程序员不能坚持维护注释。

## 注释不能美化糟糕的代码

所谓每个函数都要有 Javadoc 或是每个变量都要有注释全然是愚蠢可笑的。

能用函数或变量时就别用注释。

# 格式

保持良好的代码格式。
选用一套管理代码格式的简单规则并贯彻这些规则。

今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远的影响。
原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。
即便代码已不复存在，你的风格和律条仍然存活了下来。

## 垂直格式

### 向报纸学习
想想看写得好的报纸文章。你从上到下阅读。
在顶上，你期望有个头条，告诉你故事主题。
第一段是整个故事的大纲，给出粗线条概述，但隐藏了故事细节。
接着读下去，细节渐次增加，直至你了解所有其他细节。

报纸由许多文章组成，多数短小精悍，有的稍微长点，很少有占满一整页的。

### 垂直间隔
不同概念间的空白行。

### 垂直距离
关系密切的概念应该互相靠近。

变量声明应尽可能靠近其使用的位置。

因为函数很短，本地变量应该在函数的顶部出现。

实体变量应该在类的顶部声明，因为在设计良好的类中，它们会被大部分类使用。

**相关函数**

若某个函数调用了了另一个函数，就应该把它们放到一起，而且调用者应尽可能在被调用者前面。

**概念相关**

概念相关的代码应该放到一起。相关性越强，彼此之间的距离就应该越近。

## 水平格式

作者认为一行代码的长度应小于 120。

不必僵化。

可遵循无需滚动条到右边的原则。

### 水平方向的间隔

操作符两边加空格 *- 强调操作符有左右两个要素*

函数名和左右不加空格 *- 强调函数和参数的相关*

函数参数列表 `,` 后加空格 *- 强调参数是相互分离的*

```js
// * 两边不加空格强调优先级高
// = 两边不加空格强调优先级低
// 不幸的是多数格式化工具会让这种微妙的用法消失
var r = b*b - 4*a*c
```

**水平对齐**

没有意义，阅读顺序会由从左向右变为从上到下。

**缩进**

非常重要

## 团队规则

每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。

一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。

# 对象和数据结构

将变量设置为私有 *(private)* 有一个理由，我们不想其他人依赖这些变量。

## 数据抽象

```java
// 具体的点
public class Point {
  public double x;
  public double y;
}
```

```java
// 抽象的点
public interface Point {
  double getX();
  double getY();
  void setCartesian(double x, double y);

  double getR();
  double getTheta();
  void setPolar(double r, double theta);
} 
```

第二段代码的漂亮之处在于，你不知道该实现会是在矩形坐标系中还是在极坐标系中。*可能两个都不是！*

第一段代码则非常清除地是在矩形坐标系中实现，并要求我们单个操作那些坐标。这就暴露了实现。

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！

类并不简单采用取值器和赋值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据的本体。

第二段代码更好。我们不愿暴露数据细节，更愿意以抽象形态表述数据。

并不是用了接口和 getter/setter 就万事大吉了，要以最好的方式某个对象包含的数据，需要做严肃的思考。

## 数据、对象的反对称性

对象把数据隐藏于抽象之后，暴露操作数据的函数。
数据结构暴露其数据，没有提供有意义的函数。

```java
// 过程式代码

public class Square {
  public Point topLeft;
  public double side;
}

public class Circle {
  public Point center;
  public double radius;
}

public class Geometry {
  public final double PI = 3.14;

  public double area(Object shape) throws NoSuchShapeException {
    if (shape instanceof Square) {
      Square s = (Square) shape;
      return s.side * s.side;
    } else if (shape instanceof Circle) {
      Circle c = (Circle) shape;
      return PI * c.radius * c.radius;
    } else {
      throw new NoSuchShapeException();
    }
  }
}
```

```java
// 面向对象代码

public class Square implements Shape {
  private Point topLeft;
  private double side;

  public double area() {
    return side * side;
  }
}

public class Circle implements Shape {
  private Point center;
  private double radius;

  public double area() {
    return PI * radius * radius;
  }
}
```

对象与数据结构的二分原理：

- 过程式代码便于在不改动既有数据结构的前提下添加新的函数
- 面向对象代码便于在不改动既有函数的前提下添加新类

反过来说：

- 过程式代码难以添加新的数据结构 *- 因为必须修改所有的函数*
- 面向对象代码难以添加新的函数 *- 因为必须修改所有的类*

所以，对于面向对象比较难的事，对于过程式代码却比较容易，反之亦然！

## 迪米特法则

*The Law of Demeter*

*最少知识原则*

模块不应该了解它所操作对象的内部情况。

```java
final String outputDir = ctx.getOptions().getScratchDir().getAbsolutePath();
```

上列代码是否违反了迪米特法则呢？

这些代码是否违反了迪米特法则，取决于 `ctx`，`Options` 和 `ScratchDir` 是**对象**还是**数据结构**。

如果是对象，则它的内部结构应当隐藏不暴露，而**有关其内部细节的知识**就明显违反了迪米特法则。

如果是数据结构，没有任何的行为，则它们自然会暴露其内部结构，迪米特法则也就不适用了。

如果数据结构只简单的拥有公共变量，没有函数，而对象则拥有私有变量和公共函数，这个问题就不那么混淆。

这种混淆有时会不幸导致混合结构，一版是对象，一版是数据结构。

此类混杂增加了添加新函数的难度，也增加了添加新数据结构的难度，应避免创造这种结构。

```java
// 直接让 ctx 完成操作
BufferedOutputStream bos = ctx.createScratchFileStream(classFileName);
```

## 数据传送对象

最为精炼的数据结构是一个只有公共变量、没有函数的类。

这种数据结构有时被称为数据传送对象 *(DTO - Data Transfer Objects)*

`Bean` 结构拥有由赋值器和取值器操作的私有变量，对 `Bean` 结构的半封装会让某些 `OO` 纯化者感觉舒服些，不够通常没有其他好处。

## 小结

有时我免费希望代码能够灵活的添加新的数据类型，这时候我们运用对象，另一些时候我们希望代码能够灵活的添加新的行为，这时候我们使用数据类型和过程。
优秀的软件工程师不带成见地了解这种情形，并根据手边工作的性质选择其中的一种。

# 错误处理

错误处理很重要，但是如果它搞乱了代码逻辑，就是错误的做法。

## 使用异常而非错误码

很久以前，许多语言都不支持异常。这批语言处理和报错的手段都很有限，要么设置一个错误标识，要么返回一个错误码。

这类手段的问题在于，它们搞乱了使用者的代码。*- 必须在调用之后马上检查错误*

```java
DeviceHandle handle = getHandle(DEV1);
if (handle != DeviceHandle.INVALID) {
  // ...
} else {
  // error handling
}
```

```java
try {
  DeviceHandle handle = getHandle(DEV1);
  // ...
} catch (DeviceInvalidError e) {
  // error handling
}
```

## 环境说明

抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和位置。

## 自定义异常类

对错误的分类有很多种方式。

- 来源 *- 是来自组件还是其他地方？*
- 类型 *- 是设备错误、网络错误还是编程错误？*

不过，最重要的考虑应该是 **它们如何被捕获**

将第三方 `API` 打包是个良好的实践手段，当你打包一个第三方 `API`，你就**降低了对它的依赖**，未来你可以不太痛苦地改用其他代码库，另外也有助于模拟第三方调用。

打包的好处还在于你不必绑死在摸个特定厂商的 `API` 设计上。你可以自定义自己觉得舒服的 `API`。

## 定义常规流程

如果你遵循前文提及的建议，在业务逻辑和错误处理代码之间就会有良好的区隔。然而，这样做却把错误检测推到了程序的边缘地带。

不处理异常代码会更加简洁。

**特例模式** *(SPECIAL CASE PATTERN)*：创建一个类或配置一个对象，用来处理特例。你来处理特例，客户代码就不用处理异常了，因为异常已经被封装到特例对象中了。

## 不要返回 `null`

要讨论错误处理，就一定要提及哪些容易引发错误的做法。

第一项就是返回 `null`。

返回 `null` 值，基本上是给自己增加工作量，也是在给调用者添乱。只要有一处没检查 `null` 值，程序就会失控。

```java
public void registerItem(Item item) {
  if (item != null ){
    ItemRegistry registry = peristemtStore.getItemRegistry();
    if (registry != null) {
      Item existing = registry.getItem(item.getID());
    // ...
    }
  }
}
```

如果你打算在方法中返回 `null`，不如抛出异常，或是返回特例对象。

如果你再调用某个第三方 `API` 中可能返回 `null` 的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或是返回特例对象。

在许多情况下，特例对象都是爽口良药：

```java
// getEmplyees 可能返回 null
// 如果返回空列表，代码就会更加简洁
List <Employee> emplyees = getEmployees();
// if (employees != null) {
  for(Employee e: employees) {
    totalPay += e.getPay();
  }
// }
```

## 不要传递 `null`

在方法中返回 `null` 是糟糕的做法，但将 `null` 传给其他方法更加糟糕。

除非 `API` 要求，否则尽量避免传递 `null`。

在大多数语言中，没有良好的方法能对付由调用者意外传入的 `null`，所以恰当的做法就是禁止传入 `null`。

## 小结

整洁的代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理独立于主要逻辑之外，就能写出整洁的代码。
做到这一步，我们就能单独处理它，也及大地提升了代码的可维护性。

# 边界

我们很少控制系统中的全部软件。有时我们购买第三方程序包或使用开源代码，有时我们依靠公司中其他团队打造的组件或是子系统。
不管哪种情况，我们都得将外来代码干净利落地整合进自己的代码中。本章将介绍一些保持软件边界整洁的实践手段和技巧。

## 使用第三方代码

在接口提供者和使用者之间，存在与生俱来的张力。

- 第三方程序包和框架提供者追求普适性，以在多个环境中工作，吸引广泛的用户。
- 使用者则想要集中满足特定需求的接口。

这种张力会导致系统边界上出现问题。

如果使用类似 `Map` 这样的边界接口，就把它保留在类或者近亲类中，避免从公共 `API` 中返回边界接口或将边界接口作为参数传递给公共 `API`。

## 使用尚不存在的代码

还有另一种边界，那种将已知和未知分隔开来的边界。*（比如接口还没给）*

`Adapter` 模式

接口 `Mock`

## 整洁的边界

边界上会发生有趣的事，改动便是其中之一。有良好的软件设计，无需巨大投入和重写即可进行修改。
在使用我们控制不了的代码时，必须倍加小心，确保未来的修改不至于代价太大。

边界上的代码需要清晰的分割，并定义期望的测试。
应避免我们的代码过多地了解第三方代码中的特定信息。

依靠能控制的东西好过依靠控制不了的东西，免得日后受他控制。

# 单元测试

如今，我们的专业领域进步甚多，我们会编写测试，确保代码中的每个角落都正常的工作，我们会将代码合操作系统隔开，而不是直接调用标准计时功能，我们会伪造一套计时函数，这样就能全面的控制时间。

有了一套运行通过的测试，我们会确保任何需要用到代码的人都能方便地使用这些测试。

## TDD 三定律

谁都知道 `TDD` 要求我们在编写代码前先编写单元测试。但这条规则只是冰山一角。

看看下列三定律：

- 在编写单元测试前，不可编写生产代码
- 只允许编写刚好能够导致失败的单元测试
- 只允许编写刚好能够使失败的单元测试通过的生产代码

这三条定律将你限制在大概 `30` 秒一个的循环中，测试与生产代码一起产生。

这样写代码，每天都会产生数十个测试用例，每月会有数百个，每天则会有数千个之多，测试代码将覆盖所有生产代码，测试的代码量足以匹敌生产的代码量，导致令人生畏的管理问题。

## 保持测试整洁

测试代码必须随生产代码的演进而修改。

没有了测试代码，人们就无法确保对系统摸个部分的修改不会影响到其他部分，故障率开始增加，人们开始害怕做出改动，不再清理生产代码，害怕修改带来的损害多余收益。于是，生产代码开始腐坏，最后只剩下没有测试，纷乱而缺陷缠身的代码。

测试代码和生产代码一样重要，它可不是二等公民，它需要被思考、被设计和被照料，它应该像生产代码一样保持整洁。

**测试带来一切好处**

如果测试不能保持整洁，你就会失去它们。没了测试，你就会失去保证生产代码可扩展的一切要素。
正是单元测试让你的代码可扩展、可维护、可复用。
有了测试，你就不担心对代码的修改。
没有测试，每次修改都可能带来缺陷。

## 整洁的测试

