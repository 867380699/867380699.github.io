---
layout: post
title:  "three.js"
date:   2018-02-13

---

# demo
```html
<!DOCTYPE html>

<html>

<head>
    <meta charset="UTF-8">
    <title>First Scene</title>
    <script type="text/javascript" src="js/three.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(new THREE.Color(0xEEEEEE));
        renderer.setSize(window.innerWidth, window.innerHeight);

        // create a cube
        var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
        var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

        // position the cube
        cube.position.set(-4, 3, 0);
        // add the cube to the scene
        scene.add(cube);

        // position and point the camera to the center of the scene
        camera.position.set(-30, 40, 30); 
        camera.lookAt(scene.position);

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        // render the scene
        renderer.render(scene, camera);
    }
    window.onload = init;

</script>
</body>
</html>
```
[预览](/three.js/demo1.html)

# 几何体
# 光源
## 基础光源
## 特殊光源
# 材质

# 贴图
# 粒子
# 动画

# 加载模型
## 加载obj模型
Three.js 提供了加载obj模型的js库 `OrbitControls.js`，导入即可使用。

```html
<script type="text/javascript" src="js/OBJLoader.js"></script>
```
核心代码十分简单
```javascript
var loader = new THREE.OBJLoader();
loader.load(
    'models/house.obj',
    function(object) {
        scene.add(object);
    });
```
[预览](/three.js/load_models)

## 加载带mtl的obj模型
[预览](/three.js/load_obj_with_mtl)

![obj_with_mtl](/assets/obj_with_mtl.png)

效果如图所示，代码也不复杂。

首先导入加载obj，mtl的js库。

```html
    <script type="text/javascript" src="js/OBJLoader.js"></script>
    <script type="text/javascript" src="js/MTLLoader.js"></script>
```
接着调用 MTLLoader 加载mtl，在mtl的回调中再调用 OBJLoader 加载obj即可。
```javascript
    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.load( 'models/BrickRound.mtl', function( materials ) {
        materials.preload();

        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials( materials );
        objLoader.load( 'models/BrickRound.obj', function ( object ) {
            object.scale.set(2, 2, 2);
            scene.add( object );
        });
    });
```
注意一下我们使用的mtl文件，最后一行绑定了纹理贴图。
```mtl
# Blender MTL File: 'BrickRound.blend'
# Material Count: 1
newmtl Material.001_BrickRound0105_5_SPEC.png
Ns 96.078431
Ka 0.000000 0.000000 0.000000
Kd 0.640000 0.640000 0.640000
Ks 0.500000 0.500000 0.500000
Ni 1.000000
d 1.000000
illum 2
map_Kd models/BrickRound0105_5_SPEC.png
```

# 模型格式说明
## mtl文件
Material Library

mtl文件是由多个这样的片段组成的
```mtl
newmtl wire_224198087
    Ns 32
    d 1
    Tr 0
    Tf 1 1 1
    illum 2
    Ka 0.8784 0.7765 0.3412
    Kd 0.8784 0.7765 0.3412
    Ks 0.3500 0.3500 0.3500
    map_Kd BrickRound.png
```

这一行描述的是材质的名称，在这里是 `wire_224198087`
```mtl
newmtl wire_224198087
```
这一段描述了颜色和光照信息
```mtl
    Ns 32
    d 1
    illum 2
    Ka 0.8784 0.7765 0.3412
    Kd 0.8784 0.7765 0.3412
    Ks 0.3500 0.3500 0.3500
```
`Ka` 指定环境光的反射率，其中a是ambient。
`Kd` 指定漫反射的反射率，其中d是diffuse。
`ks` 指定镜面反射的反射率，其中s是specular。
Ka，Kd，Ks 后面的三个数分别对应 r g b ，取值范围为 0 到 1。 

`illum` 指定光了照模式，有0到10共计11中模式, 用来指定是否启用颜色，环境光，反射，透明，阴影等等。

`d` dissolve,溶解，大致是指透明度，1完全不透明，0完全透明。

`Ns` 镜面反射指数，通常值在0到1000之间，值越大，镜面感越强，值很小时几乎观察不到镜面反射。

`Ni` 光密度，范围通常在1 到 10 之间，值为1时，代表光穿过物体时不发生弯曲，值越大，弯曲越多，玻璃的光密度大约是1.5。

描述贴图的信息通常以map作为前缀
```mtl
    map_Ka -s 1 1 1 -o 0 0 0 -mm 0 1 chrome.mpc
    map_Kd -s 1 1 1 -o 0 0 0 -mm 0 1 chrome.mpc
    map_Ks -s 1 1 1 -o 0 0 0 -mm 0 1 chrome.mpc
    map_Ns -s 1 1 1 -o 0 0 0 -mm 0 1 wisp.mps
    map_d -s 1 1 1 -o 0 0 0 -mm 0 1 wisp.mps
    disp -s 1 1 .5 wisp.mps
    decal -s 1 1 1 -o 0 0 0 -mm 0 1 sand.mps
    bump -s 1 1 1 -o 0 0 0 -bm 1 sand.mpb
```
map_Kd 渲染时，纹理的值会乘以Kd
map_Kd 的格式为 `map_Kd -options args filename`

options大致有如下这些
```mtl
    -blendu on | off
    -blendv on | off
    -clamp on | off
    -imfchan r | g | b | m | l | z
    -mm base gain
    -o u v w
    -s u v w
    -t u v w
    -texres value
```

`-o` 纹理偏移量
`-s` 纹理的缩放值，用来拉伸或是收缩纹理，默认值 1 1 1

`u` 是纹理水平方向上的值
`v` 是纹理垂直方向上的值
`w` 是3D纹理的深度值

> [mtl格式详细说明 - paulbourke.net](http://paulbourke.net/dataformats/mtl/)