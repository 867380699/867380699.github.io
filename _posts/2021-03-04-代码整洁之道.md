---

layout: post
title: "代码整洁之道"
date: 2021-03-04

---

# 有意义的命名
- 使用**读得出来**的名称
- 使用**可搜索**的名称

专业的程序员了解，明确才是王道。


方法名应当是动词或动词短语，如 `postPayment`, `deletePage`, `save`。

每个概念对应一个词

反例： 同时使用 `controller`, `manager`, `driver`。

记住，只有程序员才会读你的代码。

# 函数

## 短小
函数的第一规则是要短小。第二规则是还要更短小。

`if`, `else`, `while` 等，其中的代码块应该只有一行。 *(很极端...)*

## 分层

每个函数一个抽象层级

长而具有描述性的名称，比描述性的长注释要好。

命名约定

命名方式要保持一致

`includeSetupAndTeardownPages`、`includeSetupPage`、`includeSuiteSetupPage`...

## 函数参数

最理想的参数数量是零，其次是一，再次是二，应尽量避免三。

从测试的角度看，参数多难于测试。*(条件覆盖率)*

### 标识参数

标识参数丑陋不堪。

向函数传入布尔值兼职就是骇人听闻的做法。

这样做，方法签名立刻变得复杂，大声宣布函数不止做一件事。

### 二元函数

两个参数通常没有自然顺序 `assetEqual(expected, actual)` 中， `expected` 在前， `actual` 在后， 只是一种需要学习的约定罢了。

### 参数对象

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

## 无副作用

时序性耦合

```java
appendFooter(s);
```
这个函数式把 `s` 添加到什么东西后面吗？或是把什么东西添加到了 `s` 的后面？

面向对象:

```java
report.appendFooter();
```

## 分隔指令与询问

函数要么做什么事，要么回答什么事，单二者不可得兼。

## 使用异常代替返回错误码

函数应该只做一件事情。错误处理就是一件事情。

## Don't Repeat Youself.

# 注释

> 别给糟糕的代码加注释——重新写吧！

注释并不纯然的好，实际上，注释最多也就是一种必须的恶。

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

注释存在的时间越久，就离其所描述的代码越远，原因很简单，程序员不能坚持维护注释。

## 注释不能美化糟糕的代码

所谓每个函数都要有 Javadoc 或是每个变量都要有注释全然是愚蠢可笑的。

能用函数或变量时就别用注释。

# 格式

保持良好的代码格式。
选用一套管理代码格式的简单规则并贯彻这些规则。

今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远的影响。
原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。
即便代码已不复存在，你的风格和律条仍然存活了下来。

## 垂直格式

### 向报纸学习
想想看写得好的报纸文章。你从上到下阅读。
在顶上，你期望有个头条，告诉你故事主题。
第一段是整个故事的大纲，给出粗线条概述，但隐藏了故事细节。
接着读下去，细节渐次增加，直至你了解所有其他细节。

报纸由许多文章组成，多数短小精悍，有的稍微长点，很少有占满一整页的。

### 垂直间隔
不同概念间的空白行。

### 垂直距离
关系密切的概念应该互相靠近。

变量声明应尽可能靠近其使用的位置。

因为函数很短，本地变量应该在函数的顶部出现。

实体变量应该在类的顶部声明，因为在设计良好的类中，它们会被大部分类使用。

**相关函数**

若某个函数调用了了另一个函数，就应该把它们放到一起，而且调用者应尽可能在被调用者前面。

**概念相关**

概念相关的代码应该放到一起。相关性越强，彼此之间的距离就应该越近。

## 水平格式

作者认为一行代码的长度应小于 120。

不必僵化。

可遵循无需滚动条到右边的原则。

### 水平方向的间隔

操作符两边加空格 *- 强调操作符有左右两个要素*

函数名和左右不加空格 *- 强调函数和参数的相关*

函数参数列表 `,` 后加空格 *- 强调参数是相互分离的*

```js
// * 两边不加空格强调优先级高
// = 两边不加空格强调优先级低
// 不幸的是多数格式化工具会让这种微妙的用法消失
var r = b*b - 4*a*c
```

**水平对齐**

没有意义，阅读顺序会由从左向右变为从上到下。

**缩进**

非常重要

## 团队规则

每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。

一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。

# 对象和数据结构

将变量设置为私有 *(private)* 有一个理由，我们不想其他人依赖这些变量。

## 数据抽象

```java
// 具体的点
public class Point {
  public double x;
  public double y;
}
```

```java
// 抽象的点
public interface Point {
  double getX();
  double getY();
  void setCartesian(double x, double y);

  double getR();
  double getTheta();
  void setPolar(double r, double theta);
} 
```

第二段代码的漂亮之处在于，你不知道该实现会是在矩形坐标系中还是在极坐标系中。*可能两个都不是！*

第一段代码则非常清除地是在矩形坐标系中实现，并要求我们单个操作那些坐标。这就暴露了实现。

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！

类并不简单采用取值器和赋值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据的本体。

第二段代码更好。我们不愿暴露数据细节，更愿意以抽象形态表述数据。

并不是用了接口和 getter/setter 就万事大吉了，要以最好的方式某个对象包含的数据，需要做严肃的思考。

## 数据、对象的反对称性

对象把数据隐藏于抽象之后，暴露操作数据的函数。
数据结构暴露其数据，没有提供有意义的函数。

```java
// 过程式代码

public class Square {
  public Point topLeft;
  public double side;
}

public class Circle {
  public Point center;
  public double radius;
}

public class Geometry {
  public final double PI = 3.14;

  public double area(Object shape) throws NoSuchShapeException {
    if (shape instanceof Square) {
      Square s = (Square) shape;
      return s.side * s.side;
    } else if (shape instanceof Circle) {
      Circle c = (Circle) shape;
      return PI * c.radius * c.radius;
    } else {
      throw new NoSuchShapeException();
    }
  }
}
```

```java
// 面向对象代码

public class Square implements Shape {
  private Point topLeft;
  private double side;

  public double area() {
    return side * side;
  }
}

public class Circle implements Shape {
  private Point center;
  private double radius;

  public double area() {
    return PI * radius * radius;
  }
}
```

对象与数据结构的二分原理：

- 过程式代码便于在不改动既有数据结构的前提下添加新的函数
- 面向对象代码便于在不改动既有函数的前提下添加新类

反过来说：

- 过程式代码难以添加新的数据结构 *- 因为必须修改所有的函数*
- 面向对象代码难以添加新的函数 *- 因为必须修改所有的类*

所以，对于面向对象比较难的事，对于过程式代码却比较容易，反之亦然！

## 迪米特法则

*The Law of Demeter*

*最少知识原则*

模块不应该了解它所操作对象的内部情况。

```java
final String outputDir = ctx.getOptions().getScratchDir().getAbsolutePath();
```

上列代码是否违反了迪米特法则呢？

这些代码是否违反了迪米特法则，取决于 `ctx`，`Options` 和 `ScratchDir` 是**对象**还是**数据结构**。

如果是对象，则它的内部结构应当隐藏不暴露，而**有关其内部细节的知识**就明显违反了迪米特法则。

如果是数据结构，没有任何的行为，则它们自然会暴露其内部结构，迪米特法则也就不适用了。

如果数据结构只简单的拥有公共变量，没有函数，而对象则拥有私有变量和公共函数，这个问题就不那么混淆。

这种混淆有时会不幸导致混合结构，一版是对象，一版是数据结构。

此类混杂增加了添加新函数的难度，也增加了添加新数据结构的难度，应避免创造这种结构。

```java
// 直接让 ctx 完成操作
BufferedOutputStream bos = ctx.createScratchFileStream(classFileName);
```

## 数据传送对象

最为精炼的数据结构是一个只有公共变量、没有函数的类。

这种数据结构有时被称为数据传送对象 *(DTO - Data Transfer Objects)*

`Bean` 结构拥有由赋值器和取值器操作的私有变量，对 `Bean` 结构的半封装会让某些 `OO` 纯化者感觉舒服些，不够通常没有其他好处。

## 小结

有时我免费希望代码能够灵活的添加新的数据类型，这时候我们运用对象，另一些时候我们希望代码能够灵活的添加新的行为，这时候我们使用数据类型和过程。
优秀的软件工程师不带成见地了解这种情形，并根据手边工作的性质选择其中的一种。

# 错误处理

错误处理很重要，但是如果它搞乱了代码逻辑，就是错误的做法。

## 使用异常而非错误码

很久以前，许多语言都不支持异常。这批语言处理和报错的手段都很有限，要么设置一个错误标识，要么返回一个错误码。

这类手段的问题在于，它们搞乱了使用者的代码。*- 必须在调用之后马上检查错误*

```java
DeviceHandle handle = getHandle(DEV1);
if (handle != DeviceHandle.INVALID) {
  // ...
} else {
  // error handling
}
```

```java
try {
  DeviceHandle handle = getHandle(DEV1);
  // ...
} catch (DeviceInvalidError e) {
  // error handling
}
```

## 环境说明

抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和位置。

## 自定义异常类

对错误的分类有很多种方式。

- 来源 *- 是来自组件还是其他地方？*
- 类型 *- 是设备错误、网络错误还是编程错误？*

不过，最重要的考虑应该是 **它们如何被捕获**

将第三方 `API` 打包是个良好的实践手段，当你打包一个第三方 `API`，你就**降低了对它的依赖**，未来你可以不太痛苦地改用其他代码库，另外也有助于模拟第三方调用。

打包的好处还在于你不必绑死在摸个特定厂商的 `API` 设计上。你可以自定义自己觉得舒服的 `API`。

## 定义常规流程

如果你遵循前文提及的建议，在业务逻辑和错误处理代码之间就会有良好的区隔。然而，这样做却把错误检测推到了程序的边缘地带。

不处理异常代码会更加简洁。

**特例模式** *(SPECIAL CASE PATTERN)*：创建一个类或配置一个对象，用来处理特例。你来处理特例，客户代码就不用处理异常了，因为异常已经被封装到特例对象中了。

## 不要返回 `null`

要讨论错误处理，就一定要提及哪些容易引发错误的做法。

第一项就是返回 `null`。

返回 `null` 值，基本上是给自己增加工作量，也是在给调用者添乱。只要有一处没检查 `null` 值，程序就会失控。

```java
public void registerItem(Item item) {
  if (item != null ){
    ItemRegistry registry = peristemtStore.getItemRegistry();
    if (registry != null) {
      Item existing = registry.getItem(item.getID());
    // ...
    }
  }
}
```

如果你打算在方法中返回 `null`，不如抛出异常，或是返回特例对象。

如果你再调用某个第三方 `API` 中可能返回 `null` 的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或是返回特例对象。

在许多情况下，特例对象都是爽口良药：

```java
// getEmplyees 可能返回 null
// 如果返回空列表，代码就会更加简洁
List <Employee> emplyees = getEmployees();
// if (employees != null) {
  for(Employee e: employees) {
    totalPay += e.getPay();
  }
// }
```

## 不要传递 `null`

在方法中返回 `null` 是糟糕的做法，但将 `null` 传给其他方法更加糟糕。

除非 `API` 要求，否则尽量避免传递 `null`。

在大多数语言中，没有良好的方法能对付由调用者意外传入的 `null`，所以恰当的做法就是禁止传入 `null`。

## 小结

整洁的代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理独立于主要逻辑之外，就能写出整洁的代码。
做到这一步，我们就能单独处理它，也及大地提升了代码的可维护性。

# 边界

我们很少控制系统中的全部软件。有时我们购买第三方程序包或使用开源代码，有时我们依靠公司中其他团队打造的组件或是子系统。
不管哪种情况，我们都得将外来代码干净利落地整合进自己的代码中。本章将介绍一些保持软件边界整洁的实践手段和技巧。

## 使用第三方代码

在接口提供者和使用者之间，存在与生俱来的张力。

- 第三方程序包和框架提供者追求普适性，以在多个环境中工作，吸引广泛的用户。
- 使用者则想要集中满足特定需求的接口。

这种张力会导致系统边界上出现问题。

如果使用类似 `Map` 这样的边界接口，就把它保留在类或者近亲类中，避免从公共 `API` 中返回边界接口或将边界接口作为参数传递给公共 `API`。

## 使用尚不存在的代码

还有另一种边界，那种将已知和未知分隔开来的边界。*（比如接口还没给）*

`Adapter` 模式

接口 `Mock`

## 整洁的边界

边界上会发生有趣的事，改动便是其中之一。有良好的软件设计，无需巨大投入和重写即可进行修改。
在使用我们控制不了的代码时，必须倍加小心，确保未来的修改不至于代价太大。

边界上的代码需要清晰的分割，并定义期望的测试。
应避免我们的代码过多地了解第三方代码中的特定信息。

依靠能控制的东西好过依靠控制不了的东西，免得日后受他控制。

# 单元测试

如今，我们的专业领域进步甚多，我们会编写测试，确保代码中的每个角落都正常的工作，我们会将代码合操作系统隔开，而不是直接调用标准计时功能，我们会伪造一套计时函数，这样就能全面的控制时间。

有了一套运行通过的测试，我们会确保任何需要用到代码的人都能方便地使用这些测试。

## TDD 三定律

谁都知道 `TDD` 要求我们在编写代码前先编写单元测试。但这条规则只是冰山一角。

看看下列三定律：

- 在编写单元测试前，不可编写生产代码
- 只允许编写刚好能够导致失败的单元测试
- 只允许编写刚好能够使失败的单元测试通过的生产代码

这三条定律将你限制在大概 `30` 秒一个的循环中，测试与生产代码一起产生。

这样写代码，每天都会产生数十个测试用例，每月会有数百个，每天则会有数千个之多，测试代码将覆盖所有生产代码，测试的代码量足以匹敌生产的代码量，导致令人生畏的管理问题。

## 保持测试整洁

测试代码必须随生产代码的演进而修改。

没有了测试代码，人们就无法确保对系统摸个部分的修改不会影响到其他部分，故障率开始增加，人们开始害怕做出改动，不再清理生产代码，害怕修改带来的损害多余收益。于是，生产代码开始腐坏，最后只剩下没有测试，纷乱而缺陷缠身的代码。

测试代码和生产代码一样重要，它可不是二等公民，它需要被思考、被设计和被照料，它应该像生产代码一样保持整洁。

**测试带来一切好处**

如果测试不能保持整洁，你就会失去它们。没了测试，你就会失去保证生产代码可扩展的一切要素。
正是单元测试让你的代码可扩展、可维护、可复用。
有了测试，你就不担心对代码的修改。
没有测试，每次修改都可能带来缺陷。

## 整洁的测试

整洁的测试有三个要素：**可读性**，**可读性**和**可读性**。

在单元测试中，可读性甚至比在生产代码中还重要。

Q: 测试如何才能做到可读？
A: 和其他代码一样：明确，简洁，还有足够的表达力。

在测试中，我们要以尽可能少的文字表达大量的内容。


`BUILD-OPERATE-CHECK` 模式

面向测试领域的测试语言，这种 `API` 并非期初就设计出来，而是在对测试代码重构时逐渐演进的。
守规矩的开发者会将他们的测试代码重构为更简洁、更具表达力的形式。

### 双重标准

```java
@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
  hw.setTemp(WAY_TOO_COLD);
  // 细节太多
  controller.tic();
  // 难以阅读
  assertTrue(hw.heaterState());
  assertTrue(hw.blowerState());
  assertFalse(hw.coolerState());
  assertFalse(hw.hiTempAlarm());
  assertTrue(hw.loTempAlarm());
}
```
重构后：
```java
@Test
public void turnOnLoTempAlarmAtThreashold throws Exception {
  wayTooCold();
  // 大写表示打开，小写表示关闭，
  // 尽管破坏了思维映射的规则，但这种情况下是使用的，只要明白其含义，就能迅速理解
  assertEqual("HBchL", hw.getState());
}
```

比如在嵌入式系统中，CPU 和内存资源都很有限，而在测试环境中，可能完全不受限制。*（可以写一些效率不够高但是简洁清晰的代码）*

## 每个测试一个断言

有个流派认为 `JUnit` 中每个测试函数都应该有且只有一个断言语句。

这条规则看似过于苛刻，但好处是所有的测试都归结为一个可快速理解的结论。

单个测试中的断言数量应该最小化，但也不必太过苛求单个断言准则。

`given-when-then` 约定。

**每个测试一个概念**

更好一些的规则或许是每个测试函数中只测试一个概念。

## F.I.R.S.T.

整洁的测试还遵循以下 5 条规则：

1. **快速** *(Fast)*
  - 测试运行缓慢，人们就不会频繁的运行它
2. **独立** *(Independent)*
  - 测试应该互相独立，每个测试应该可以单独运行
  - 当测试相互依赖时，一个测试没通过就会导致一连串的测试失败
3. **可重复** *(Repeatable)*
  - 测试应当能在任何环境中重复通过
  - 当测试不能在任何环境中重复，你总有个解释其失败的借口
  - 当环境不具备时，你也无法运行测试
4. **自足检验** *(Self-Validating)*
  - 测试应当有布尔值输出
  - 无论成功或是失败，不应该通过查看日志，人工对比来判断测试是否通过
5. **及时** *(Timely)*
  - 测试应及时编写
  - 测试代码应该恰好在 使其通过的生产代码 之前编写
  - 如果在编写生产代码之后编写测试，会发现生产代码难以测试，你可能会认为某些生产代码本身难以测试，你可能不会去设计可测试的代码

  # 类

  尽管已经讨论了许多关于代码语句及函数的表达力，但如果我们不将注意力放到代码组织的更高层面，我们还是无法得到整洁的代码。

## 类的组织

遵循标准的 `Java` 约定，类应该从一组变量开始。

- 公共静态变量最先
- 其次私有静态变量和私有成员变量
- 很少会有公共变量

**封装**

我们喜欢爆出变量和工具函数的私有性，但并不执著于此。

## 类应该短小

关于类的第一条规则就是短小。第二条是还要更短小。

对于函数我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，计算**权责***（responsibility）*

类的名称应当描述其权责。命名正是帮助判断类的长度的第一个手段。

如果无法为某个类精确命名，这个类大概就太长，类名越含混，该类就可能拥有过多的权责。

例如：如果类名中包含 `Processor`，`Manager`，`Super` 这类模糊的词，往往存在不恰当的权责聚集。

我们应该能够用大概 25 个单词描述一个类，且不用 `if`，`and`，`or` 或是 `but` 等词汇。

### 单一职责原则 *SRP*

类或模块有且只有一条加以修改的理由。

鉴别权责*（修改的理由）*常常帮助我们在代码中认识到并创建出更好的抽象。

`SRP` 是 `OO` 设计中最为重要的概念之一，也是较为容易理解的和遵循的概念之一，奇怪的是 `SRP` 往往也是最容易被破坏的原则。

让软件能工作和保持软件整洁是两种截然不同的工作。大多数人脑力有限，只能更多地把精力放在让代码能工作上，这完全正确，但问题是太多人在程序能工作时就以为万事大吉了，没有把思维转向代码组织和整洁上。我们直接转向下一个问题，而不是回头将臃肿的类切分成只有单一之职责的去耦式单元。

于此同时，许多开发者害怕数量巨大的短小类会导致难以一目了然地抓住全局。
他们认为，要搞清楚一件较大的工作如何完成，就得在类与类之间找来找去。

你是想把工具归置到有许多抽屉、每个抽屉装有定义和标记良好的组件的工具箱，还是想要少数几个能随便把所有东西扔进去的抽屉？

每个达到一定规模的系统都会包括大量逻辑，管理这种复杂系统的首要目标就是加以组织，以便开发者知道到哪儿能找到东西，并且在某个特定时间只需要理解直接有关的复杂性。反之，拥有巨大、多目的的类的系统，总是让我们在目前并不需要了解的一大堆东西中艰难跋涉。

再强调一下：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。

### 内聚

类应该只有少数实体变量。类中的每个方法都应该操作一个或多个这种变量。

通常而言，方法操作的变量越多，就越粘聚到类上。如果一个类中每个变量都被方法所用到，则该类具有最大的内聚性。

一般来说，创造这种极大化内聚的类是不可取也不可能的，但我们希望内聚性保持在较高位置，内聚性高说明类中的方法和变量互相依赖、互相结合成一个逻辑整体。

### 保持内聚性就会得到许多短小的类

当类丧失了内聚性，就拆分它！

## 为了修改而组织

对于多数系统，修改将一直持续。在整洁的系统中，我们对类加以组织，以降低修改的风险。

```java
public class Sql {
  public Sql(String table, Column[] columns)
  public String create()
  public String insert(Object[] fields)
  public String selectAll()
  public String findByKey(String keyColumn, String keyValue)
  public String select(Column column, String pattern)
  private String columnList(Column[] columns)
  private String valuesList(Object[] fields, final Column[] columns)
}
```

这个类还没写完，所以暂不支持 `update`，当需要增加 `update` 语句时，我们就得「打开」这个类进行修改，于是风险也随之而来，对类的任何修改都有可能破坏类中的其他代码。

当我们需要增加一种新的语句时，就要修改 `Sql` 类，当我们想要修改单个语句，比如让 `select` 支持子查询，也需要修改 `Sql` 类。存在两个修改的理由，说明违反了 `SRP` 原则。

```java
abstract public class Sql {
  public Sql(String table, Column[] columns)
  abstract public String gengerate()
}

public class SelectSql extends Sql {
  public SelectSql(String table, Column[] columns)
  @Override public String generate()
}

public class InsertSql extends Sql {
  public InsertSql(String table, Column[] columns, Object[] fields)
  @Override public String generate()
  private String valuesList(Object[] fields, final Column[] columns)
}

public class ColumnList {
  public ColumnList(Column[] columns)
  public String generate()
}

// ...
```

每个接口都重构到 `Sql` 的派生类中，`valueList` 直接移动到了需要使用它们的地方，私有方法也被划分到了独立的工具类中。

每个类中的代码都变得极为简单，理解每个类花费的时间几乎缩减到几零。函数对其他函数造成破坏的风险也几乎消失。从测试的角度看，验证每一处的逻辑也变成了极为简单的任务，因为类与类之间相互隔离了。

当需要增加 `update` 语句时，现存类无需做任何修改，这也同等重要！

重新架构的 `Sql` 逻辑百利而无一害，符合 `SRP`，同时也符合 `OCP`：类应当对扩展开放，对修改关闭。

`子类化`

我们希望将系统打造成在添加或修改特性时尽可能少惹麻烦的架子。在理想的系统中，我们通过扩展系统而非修改现有代码来添加新特性。

**隔离修改**

需求会改变，所以代码也会改变。

具体类包含实现细节，而接口则只呈现概念。依赖于具体细节的客户类，当细节改变时，就会有风险。我们可以借助接口和抽象来隔离这些细节带来的影响。

对具体细节的依赖，给系统的测试带来了挑战。

比如一个依赖外部 `API` 的类，预期直接依赖外部 `API`，不如创建一个接口：

```java
public interface StockExchange {
  Money currentPrice(String symbol);
}

public class Portfolio {
  private StockExchange stockExchange;

  public Portfolio(StockExhange exchange) {
    this.stockExchange = exchange;
  }
}
```

现在就可以为 `StockExchange` 接口创建可测试的尝试性实现了。

如果系统解耦到可以测试的程度，也就更加灵活，更加可复用。部件之间的解耦代表着系统中的元素互相隔离的很好。隔离也让系统对每个元素的理解变得更加容易。

通过降低链接度，我们就遵循了另一条类设计原则 —— **依赖倒置原则***（Dependency Inversion Principle - DIP）*。

本质而言，`DIP` 认为类应当依赖于抽象而不是具体细节。

我们的 `Protfilio` 类不再依赖 `TokyoStickExchange` 类的实现细节，而是依赖于 `StockExchange` 接口。`StockExchange` 接口呈现的是有关查询某只股票价格的抽象概念。这种抽象隔离了所有询价的细节，包括价格数据来自何处之类。

# 系统

