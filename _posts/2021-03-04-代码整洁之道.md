---

layout: post
title: "代码整洁之道"
date: 2021-03-04

---

# 有意义的命名
- 使用**读得出来**的名称
- 使用**可搜索**的名称

专业的程序员了解，明确才是王道。


方法名应当是动词或动词短语，如 `postPayment`, `deletePage`, `save`。

每个概念对应一个词

反例： 同时使用 `controller`, `manager`, `driver`。

记住，只有程序员才会读你的代码。

# 函数

## 短小
函数的第一规则是要短小。第二规则是还要更短小。

`if`, `else`, `while` 等，其中的代码块应该只有一行。 *(很极端...)*

## 分层

每个函数一个抽象层级

长而具有描述性的名称，比描述性的长注释要好。

命名约定

命名方式要保持一致

`includeSetupAndTeardownPages`、`includeSetupPage`、`includeSuiteSetupPage`...

## 函数参数

最理想的参数数量是零，其次是一，再次是二，应尽量避免三。

从测试的角度看，参数多难于测试。*(条件覆盖率)*

### 标识参数

标识参数丑陋不堪。

向函数传入布尔值兼职就是骇人听闻的做法。

这样做，方法签名立刻变得复杂，大声宣布函数不止做一件事。

### 二元函数

两个参数通常没有自然顺序 `assetEqual(expected, actual)` 中， `expected` 在前， `actual` 在后， 只是一种需要学习的约定罢了。

### 参数对象

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

## 无副作用

时序性耦合

```java
appendFooter(s);
```
这个函数式把 `s` 添加到什么东西后面吗？或是把什么东西添加到了 `s` 的后面？

面向对象:

```java
report.appendFooter();
```

## 分隔指令与询问

函数要么做什么事，要么回答什么事，单二者不可得兼。

## 使用异常代替返回错误码

函数应该只做一件事情。错误处理就是一件事情。

## Don't Repeat Youself.

# 注释

> 别给糟糕的代码加注释——重新写吧！

注释并不纯然的好，实际上，注释最多也就是一种必须的恶。

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

注释存在的时间越久，就离其所描述的代码越远，原因很简单，程序员不能坚持维护注释。

## 注释不能美化糟糕的代码

所谓每个函数都要有 Javadoc 或是每个变量都要有注释全然是愚蠢可笑的。

能用函数或变量时就别用注释。

# 格式

保持良好的代码格式。
选用一套管理代码格式的简单规则并贯彻这些规则。

今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远的影响。
原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。
即便代码已不复存在，你的风格和律条仍然存活了下来。

## 垂直格式

### 向报纸学习
想想看写得好的报纸文章。你从上到下阅读。
在顶上，你期望有个头条，告诉你故事主题。
第一段是整个故事的大纲，给出粗线条概述，但隐藏了故事细节。
接着读下去，细节渐次增加，直至你了解所有其他细节。

报纸由许多文章组成，多数短小精悍，有的稍微长点，很少有占满一整页的。

### 垂直间隔
不同概念间的空白行。

### 垂直距离
关系密切的概念应该互相靠近。

变量声明应尽可能靠近其使用的位置。

因为函数很短，本地变量应该在函数的顶部出现。

实体变量应该在类的顶部声明，因为在设计良好的类中，它们会被大部分类使用。

**相关函数**

若某个函数调用了了另一个函数，就应该把它们放到一起，而且调用者应尽可能在被调用者前面。

**概念相关**

概念相关的代码应该放到一起。相关性越强，彼此之间的距离就应该越近。

## 水平格式

作者认为一行代码的长度应小于 120。

不必僵化。

可遵循无需滚动条到右边的原则。

### 水平方向的间隔

操作符两边加空格 *- 强调操作符有左右两个要素*

函数名和左右不加空格 *- 强调函数和参数的相关*

函数参数列表 `,` 后加空格 *- 强调参数是相互分离的*

```js
// * 两边不加空格强调优先级高
// = 两边不加空格强调优先级低
// 不幸的是多数格式化工具会让这种微妙的用法消失
var r = b*b - 4*a*c
```

**水平对齐**

没有意义，阅读顺序会由从左向右变为从上到下。

**缩进**

非常重要

## 团队规则

每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。

一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。

# 对象和数据结构

将变量设置为私有 *(private)* 有一个理由，我们不想其他人依赖这些变量。

## 数据抽象

```java
// 具体的点
public class Point {
  public double x;
  public double y;
}
```

```java
// 抽象的点
public interface Point {
  double getX();
  double getY();
  void setCartesian(double x, double y);

  double getR();
  double getTheta();
  void setPolar(double r, double theta);
} 
```

第二段代码的漂亮之处在于，你不知道该实现会是在矩形坐标系中还是在极坐标系中。*可能两个都不是！*

第一段代码则非常清除地是在矩形坐标系中实现，并要求我们单个操作那些坐标。这就暴露了实现。

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！

类并不简单采用取值器和赋值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据的本体。

第二段代码更好。我们不愿暴露数据细节，更愿意以抽象形态表述数据。

并不是用了接口和 getter/setter 就万事大吉了，要以最好的方式某个对象包含的数据，需要做严肃的思考。

## 数据、对象的反对称性

对象把数据隐藏于抽象之后，暴露操作数据的函数。
数据结构暴露其数据，没有提供有意义的函数。

```java
// 过程式代码

public class Square {
  public Point topLeft;
  public double side;
}

public class Circle {
  public Point center;
  public double radius;
}

public class Geometry {
  public final double PI = 3.14;

  public double area(Object shape) throws NoSuchShapeException {
    if (shape instanceof Square) {
      Square s = (Square) shape;
      return s.side * s.side;
    } else if (shape instanceof Circle) {
      Circle c = (Circle) shape;
      return PI * c.radius * c.radius;
    } else {
      throw new NoSuchShapeException();
    }
  }
}
```

```java
// 面向对象代码

public class Square implements Shape {
  private Point topLeft;
  private double side;

  public double area() {
    return side * side;
  }
}

public class Circle implements Shape {
  private Point center;
  private double radius;

  public double area() {
    return PI * radius * radius;
  }
}
```

对象与数据结构的二分原理：

- 过程式代码便于在不改动既有数据结构的前提下添加新的函数
- 面向对象代码便于在不改动既有函数的前提下添加新类

反过来说：

- 过程式代码难以添加新的数据结构 *- 因为必须修改所有的函数*
- 面向对象代码难以添加新的函数 *- 因为必须修改所有的类*

所以，对于面向对象比较难的事，对于过程式代码却比较容易，反之亦然！

## 迪米特法则

*The Law of Demeter*

*最少知识原则*

模块不应该了解它所操作对象的内部情况。

```java
final String outputDir = ctx.getOptions().getScratchDir().getAbsolutePath();
```

上列代码是否违反了迪米特法则呢？

这些代码是否违反了迪米特法则，取决于 `ctx`，`Options` 和 `ScratchDir` 是**对象**还是**数据结构**。

如果是对象，则它的内部结构应当隐藏不暴露，而**有关其内部细节的知识**就明显违反了迪米特法则。

如果是数据结构，没有任何的行为，则它们自然会暴露其内部结构，迪米特法则也就不适用了。

如果数据结构只简单的拥有公共变量，没有函数，而对象则拥有私有变量和公共函数，这个问题就不那么混淆。

这种混淆有时会不幸导致混合结构，一版是对象，一版是数据结构。

此类混杂增加了添加新函数的难度，也增加了添加新数据结构的难度，应避免创造这种结构。

```java
// 直接让 ctx 完成操作
BufferedOutputStream bos = ctx.createScratchFileStream(classFileName);
```

## 数据传送对象

最为精炼的数据结构是一个只有公共变量、没有函数的类。

这种数据结构有时被称为数据传送对象 *(DTO - Data Transfer Objects)*

`Bean` 结构拥有由赋值器和取值器操作的私有变量，对 `Bean` 结构的半封装会让某些 `OO` 纯化者感觉舒服些，不够通常没有其他好处。

## 小结

有时我免费希望代码能够灵活的添加新的数据类型，这时候我们运用对象，另一些时候我们希望代码能够灵活的添加新的行为，这时候我们使用数据类型和过程。
优秀的软件工程师不带成见地了解这种情形，并根据手边工作的性质选择其中的一种。

# 错误处理

错误处理很重要，但是如果它搞乱了代码逻辑，就是错误的做法。

## 使用异常而非错误码

很久以前，许多语言都不支持异常。这批语言处理和报错的手段都很有限，要么设置一个错误标识，要么返回一个错误码。

这类手段的问题在于，它们搞乱了使用者的代码。*- 必须在调用之后马上检查错误*

```java
DeviceHandle handle = getHandle(DEV1);
if (handle != DeviceHandle.INVALID) {
  // ...
} else {
  // error handling
}
```

```java
try {
  DeviceHandle handle = getHandle(DEV1);
  // ...
} catch (DeviceInvalidError e) {
  // error handling
}
```

## 环境说明

抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和位置。

## 自定义异常类

对错误的分类有很多种方式。

- 来源 *- 是来自组件还是其他地方？*
- 类型 *- 是设备错误、网络错误还是编程错误？*

不过，最重要的考虑应该是 **它们如何被捕获**

将第三方 `API` 打包是个良好的实践手段，当你打包一个第三方 `API`，你就**降低了对它的依赖**，未来你可以不太痛苦地改用其他代码库，另外也有助于模拟第三方调用。

打包的好处还在于你不必绑死在摸个特定厂商的 `API` 设计上。你可以自定义自己觉得舒服的 `API`。

## 定义常规流程

如果你遵循前文提及的建议，在业务逻辑和错误处理代码之间就会有良好的区隔。然而，这样做却把错误检测推到了程序的边缘地带。

不处理异常代码会更加简洁。

**特例模式** *(SPECIAL CASE PATTERN)*：创建一个类或配置一个对象，用来处理特例。你来处理特例，客户代码就不用处理异常了，因为异常已经被封装到特例对象中了。

## 不要返回 `null`

要讨论错误处理，就一定要提及哪些容易引发错误的做法。

第一项就是返回 `null`。

返回 `null` 值，基本上是给自己增加工作量，也是在给调用者添乱。只要有一处没检查 `null` 值，程序就会失控。

```java
public void registerItem(Item item) {
  if (item != null ){
    ItemRegistry registry = peristemtStore.getItemRegistry();
    if (registry != null) {
      Item existing = registry.getItem(item.getID());
    // ...
    }
  }
}
```