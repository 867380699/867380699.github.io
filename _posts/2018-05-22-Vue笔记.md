---

layout: post
title: "Vue笔记"
date: 2018-05-22
tags: [ javascript ]
---
# 简介
指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊特性。
`v-bind`, `v-if`, `v-for`, `v-on`
# 绑定数据
```html
<div id="app">
  <span v-bind:title="message">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
  </span>
</div>
```
```js
var app2 = new Vue({
  el: '#app',
  data: {
    message: '页面加载于 ' + new Date().toLocaleString()
  }
})
```
# 表单输入绑定
你可以用 `v-model` 指令在表单 `<input>` 及 `<textarea>` 元素上创建双向数据绑定。
```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```
# 参数
一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML 特性：
```html
<a v-bind:href="url">...</a>
```
在这里 href 是参数，告知 `v-bind` 指令将该元素的 `href` 特性与表达式 `url` 的值绑定。

另一个例子是 `v-on` 指令，它用于监听 DOM 事件：
```html
<a v-on:click="doSomething">...</a>
```
在这里参数是监听的事件名。我们也会更详细地讨论事件处理。

# 缩写
Vue.js 为 `v-bind` 和 `v-on` 这两个最常用的指令，提供了特定简写：
## v-bind
```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>
```
## v-on
```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>
```

# 单文件组件
文件扩展名为 `.vue` 的 `single-file components(单文件组件)`

```html
<template>
<!-- ...模板 -->
</template>

<script>
// ...
</script>
<style>
/* ... */
</style>
```

# 自定义组件

# Reactivity in Depth
Due to the limitations of modern JavaScript (and the abandonment of Object.observe), Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during **instance initialization**, **a property must be present in the data object in order for Vue to convert it and make it reactive**{:style="color:red"}. 

```js
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` is now reactive

vm.b = 2
// `vm.b` is NOT reactive
```

When you pass a plain JavaScript object to a Vue instance as its data option, Vue will walk through all of its properties and convert them to `getter/setters` using `Object.defineProperty`. 

Every component instance has a corresponding `watcher` instance, which records any properties *“touched”* during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.

![](/assets/vue-reactive.png)

Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the `Vue.set(object, propertyName, value)` method:

```js
Vue.set(vm.someObject, 'b', 2)
```

You can also use the `vm.$set` instance method, which is an alias to the global `Vue.set`:
```js
this.$set(this.someObject, 'b', 2)
```

## For Arrays
Vue cannot detect the following changes to an array:

- When you directly set an item with the index, e.g. `vm.items[indexOfItem] = newValue`

```js
Vue.set(vm.items, indexOfItem, newValue)
```

Vue performs DOM updates **asynchronously**.

you can use `Vue.nextTick(callback)` immediately after the data is changed. 

# 插件
通过全局方法 `Vue.use()` 使用插件。它需要在你调用 `new Vue()` 启动应用之前完成：

```js
// 调用 `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  // ...组件选项
})
```

# Vue
## 全局 API
### Vue.extend
```js
Vue.extend( options )
```
## 选项 / DOM
### el
### template
### render
> `Vue` 选项中的 `render` 函数若存在，则 `Vue` 构造函数不会使用 `template` 选项或 `el` 选项编译渲染。

## 实例方法
### vm.$mount
```js
var MyComponent = Vue.extend({
  template: '<div>Hello!</div>'
})

// 在文档之外渲染并且随后挂载
var component = new MyComponent().$mount()
document.getElementById('app').appendChild(component.$el)
```

## 生命周期(Lifecycle)

# Vue Router

## Navigation Guards

> <https://router.vuejs.org/>

# Vuex
## State
`mapState` 辅助函数

当映射的计算属性的名称与 `state` 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。
```js
export default {
  computed: {
    ...mapState([
      // 映射 this.count 为 store.state.count
      'count'
    ])
  }
}

```
## Getter
可以认为是 store 的计算属性

```js
const store = new Vuex.Store({
  // ...
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
    // getter 作为第二个参数，可以调用其他 getter
    doneTodosCount: (state, getters) => {
      return getters.doneTodos.length
    }
  }
})
```

```js
export const store = new Vuex.Store({
  // ...
  // 带参数的Getter
  getters: {
    getSubToc: state => (...path) => _.get(state.toc, path),
  }
})
```

`mapGetters` 辅助函数

```js
import { mapGetters } from 'vuex'

export default {
  // ...
  computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
  }
}
```

## Mutation

**`Mutation` 需遵守 Vue 的响应规则**

既然 `Vuex` 的 `store` 中的状态是响应式的，那么当我们变更状态时，监视状态的 `Vue` 组件也会自动更新。这也意味着 `Vuex` 中的 `mutation` 也需要与使用 `Vue` 一样遵守一些注意事项：

最好提前在你的 `store` 中初始化好所有所需属性。

当需要在对象上添加新属性时，你应该

使用 `Vue.set(obj, 'newProp', 123)`, 或者

以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：

```
state.obj = { ...state.obj, newProp: 123 }
```

**`mutation` 必须是同步函数**。在 `Vuex` 中，`mutation` 都是同步事务：

```js
store.commit('increment')
// 任何由 "increment" 导致的状态变更都应该在此刻完成。
```

**使用常量替代 Mutation 事件类型**

把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 `mutation` 一目了然


## Action
`Action` 类似于 `mutation`，不同在于：

- `Action` 提交的是 `mutation`，而不是直接变更状态。
- `Action` 可以包含任意异步操作。

`Action` 通过 `store.dispatch` 方法触发：
```js
store.dispatch('increment')
```

> <https://vuex.vuejs.org/zh/guide/>

# 简易绑定

## getter setter

```js
var obj = {
    data: {
        a: 1
    },
    get a() {
        return this.data.a
    },
    set a(val) {
        this.data.a = val
    }
}
obj.a // 1
obj.a = 2
obj.a // 2
obj.data.a // 2
```

## defineProperty

```js
var obj = {
    data: {
        num: 10,
        name: 'sword'
    },
}
for(let prop in obj.data) {
    Object.defineProperty(obj, prop, {
        get: function(){return obj.data[prop]},
    set: function(val){obj.data[prop] = val}
    })
}

obj.num // 10
obj.name // "sword"
obj.name = "armour"
obj.data.name // "armour"
```
# Render Functions
```js
Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // tag name
      this.$slots.default // array of children
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
```

```html
<anchored-heading :level="1">Hello world!</anchored-heading>
<anchored-heading :level="2">test</anchored-heading>
```

> <https://vuejs.org/v2/guide/render-function.html>

# Tricks
重置Data
```js
Object.assign(this.$data, this.$options.data.apply(this))
```

chain `v-model`

```html
<input v-model="searchText">
```
does the same thing as:

```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```

```html
// Address.vue
<template>
  <div>
    <quill-editor v-model="content" :options="option">
      <div id="toolbar" slot="toolbar" ref="toolbar">
        <button class="ql-bold">Bold</button>
        <button class="ql-italic">Italic</button>
        <button class="ql-image"></button>
      </div>
    </quill-editor>
  </div>
</template>
```
```js
import { quillEditor } from 'vue-quill-editor';

export default {
  props: ['value'],
  components: { quillEditor },
  computed: {
    content: {
      get() { return this.value; },
      set(content) { this.$emit('input', content); },
    },
  }
}
```

# Debug

print store in console:

```js
document.getElementsByTagName('div')[0].__vue__.$store.state
```

# Tools
## Vetur
### Project Setup
At project root create a `jsconfig.json`.

```json
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
  }
}
```

> <https://vuejs.github.io/vetur/setup.html#project-setup>

# 资料

> [官方指南](https://cn.vuejs.org/v2/guide/)
> [vue test utils](https://vue-test-utils.vuejs.org/)