---

layout: post
title: "Vue笔记"
date: 2018-05-22
tags: [ javascript ]
---
# 简介
指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊特性。
`v-bind`, `v-if`, `v-for`, `v-on`
# 绑定数据
```html
<div id="app">
  <span v-bind:title="message">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
  </span>
</div>
```
```js
var app2 = new Vue({
  el: '#app',
  data: {
    message: '页面加载于 ' + new Date().toLocaleString()
  }
})
```
# 表单输入绑定
你可以用 `v-model` 指令在表单 `<input>` 及 `<textarea>` 元素上创建双向数据绑定。
```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```
# 参数
一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML 特性：
```html
<a v-bind:href="url">...</a>
```
在这里 href 是参数，告知 `v-bind` 指令将该元素的 `href` 特性与表达式 `url` 的值绑定。

另一个例子是 `v-on` 指令，它用于监听 DOM 事件：
```html
<a v-on:click="doSomething">...</a>
```
在这里参数是监听的事件名。我们也会更详细地讨论事件处理。

# 缩写
Vue.js 为 `v-bind` 和 `v-on` 这两个最常用的指令，提供了特定简写：
## v-bind
```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>
```
## v-on
```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>
```

# 单文件组件
文件扩展名为 `.vue` 的 `single-file components(单文件组件)`

```html
<template>
<!-- ...模板 -->
</template>

<script>
// ...
</script>
<style>
/* ... */
</style>
```

# 自定义组件

# 注意
Due to the limitations of modern JavaScript (and the abandonment of Object.observe), Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the data object in order for Vue to convert it and make it reactive. 

```js
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` is now reactive

vm.b = 2
// `vm.b` is NOT reactive
```
# Vue
## 全局 API
### Vue.extend
```js
Vue.extend( options )
```
## 选项 / DOM
### el
### template
### render
> `Vue` 选项中的 `render` 函数若存在，则 `Vue` 构造函数不会使用 `template` 选项或 `el` 选项编译渲染。

## 实例方法 / 生命周期
### vm.$mount
```js
var MyComponent = Vue.extend({
  template: '<div>Hello!</div>'
})

// 在文档之外渲染并且随后挂载
var component = new MyComponent().$mount()
document.getElementById('app').appendChild(component.$el)
```

# Vue Router

## Navigation Guards

> <https://router.vuejs.org/>

# Vuex
## State
`mapState` 辅助函数

当映射的计算属性的名称与 `state` 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。
```js
export default {
  computed: {
    ...mapState([
      // 映射 this.count 为 store.state.count
      'count'
    ])
  }
}

```
## Getter
可以认为是 store 的计算属性

```js
const store = new Vuex.Store({
  // ...
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
    // getter 作为第二个参数，可以调用其他 getter
    doneTodosCount: (state, getters) => {
      return getters.doneTodos.length
    }
  }
})
```

```js
export const store = new Vuex.Store({
  // ...
  // 带参数的Getter
  getters: {
    getSubToc: state => (...path) => _.get(state.toc, path),
  }
})
```

`mapGetters` 辅助函数

```js
import { mapGetters } from 'vuex'

export default {
  // ...
  computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
  }
}
```

## Mutation

**`Mutation` 需遵守 Vue 的响应规则**

既然 `Vuex` 的 `store` 中的状态是响应式的，那么当我们变更状态时，监视状态的 `Vue` 组件也会自动更新。这也意味着 `Vuex` 中的 `mutation` 也需要与使用 `Vue` 一样遵守一些注意事项：

最好提前在你的 `store` 中初始化好所有所需属性。

当需要在对象上添加新属性时，你应该

使用 `Vue.set(obj, 'newProp', 123)`, 或者

以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：

```
state.obj = { ...state.obj, newProp: 123 }
```

**`mutation` 必须是同步函数**。在 `Vuex` 中，`mutation` 都是同步事务：

```js
store.commit('increment')
// 任何由 "increment" 导致的状态变更都应该在此刻完成。
```

**使用常量替代 Mutation 事件类型**

把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 `mutation` 一目了然


## Action
`Action` 类似于 `mutation`，不同在于：

- `Action` 提交的是 `mutation`，而不是直接变更状态。
- `Action` 可以包含任意异步操作。

`Action` 通过 `store.dispatch` 方法触发：
```js
store.dispatch('increment')
```

> <https://vuex.vuejs.org/zh/guide/>

# 简易绑定

## getter setter

```js
var obj = {
    data: {
        a: 1
    },
    get a() {
        return this.data.a
    },
    set a(val) {
        this.data.a = val
    }
}
obj.a // 1
obj.a = 2
obj.a // 2
obj.data.a // 2
```

## defineProperty

```js
var obj = {
    data: {
        num: 10,
        name: 'sword'
    },
}
for(let prop in obj.data) {
    Object.defineProperty(obj, prop, {
        get: function(){return obj.data[prop]},
    set: function(val){obj.data[prop] = val}
    })
}

obj.num // 10
obj.name // "sword"
obj.name = "armour"
obj.data.name // "armour"
```

# Tricks
重置Data
```js
Object.assign(this.$data, this.$options.data.apply(this))
```

# 资料

> [官方指南](https://cn.vuejs.org/v2/guide/)
> [vue test utils](https://vue-test-utils.vuejs.org/)